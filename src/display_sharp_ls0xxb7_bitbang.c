// Zephyr bit-banging display driver for Sharp Memory LCDs with the 6-bit
// parallel interface.

// This driver assumes VCOM/VB and VA signals are generated by a separate
// process.

// API docs:
// https://docs.zephyrproject.org/latest/doxygen/html/group__display__interface.html

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(sharp_mip_parallel, CONFIG_DISPLAY_LOG_LEVEL);

#include <stdint.h>
#include <zephyr/drivers/display.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/kernel.h>

#include "display_sharp_ls0xxb7_bitbang_nrf_macros.h"

// Private mutable data for the driver.
struct sharp_mip_data {};

// Private const data for the driver.
struct sharp_mip_config {
  uint16_t height;
  uint16_t width;
  struct gpio_dt_spec vcom_vb;
  struct gpio_dt_spec va;

  struct gpio_dt_spec intb;
  struct gpio_dt_spec gsp;
  struct gpio_dt_spec gck;
  struct gpio_dt_spec gen;
  struct gpio_dt_spec bsp;
  struct gpio_dt_spec bck;
  struct gpio_dt_spec rgb[6];
};

#define SET_GPIO_OUTPUT(ret, name)                       \
  do {                                                   \
    if (!device_is_ready(name.port)) {                   \
      LOG_ERR(#name " GPIO port not ready");             \
      return -ENODEV;                                    \
    }                                                    \
    ret = gpio_pin_configure_dt(&name, GPIO_OUTPUT);     \
    if (ret < 0) {                                       \
      LOG_ERR(#name " GPIO pin config failed: %d", ret); \
      return ret;                                        \
    }                                                    \
  } while (0)

static int sharp_mip_init(const struct device *dev) {
  const struct sharp_mip_config *config = dev->config;
  int ret;

  SET_GPIO_OUTPUT(ret, config->intb);
  SET_GPIO_OUTPUT(ret, config->gsp);
  SET_GPIO_OUTPUT(ret, config->gck);
  SET_GPIO_OUTPUT(ret, config->gen);
  SET_GPIO_OUTPUT(ret, config->bsp);
  SET_GPIO_OUTPUT(ret, config->bck);
  for (int i = 0; i < sizeof(config->rgb) / sizeof(config->rgb[0]); i++) {
    SET_GPIO_OUTPUT(ret, config->rgb[i]);
  }

  // gpio_pin_configure_dt(&config->vcom_vb, GPIO_OUTPUT);
  // gpio_pin_configure_dt(&config->va, GPIO_OUTPUT);

  LOG_DBG("Sharp MIP display initialized. Resolution: %dx%d", config->width,
          config->height);

  return 0;
}

static inline void set_rgb(int y, int x) {
  if (y < 100) {
    // This looks actually white!
    SET_RGB(0b000011);
    return;
    // } else if (y < (DISPLAY_H * 2) / 3) {
    //   SET_RGB(0b001100);
    //   // SET_RGB(0b011111);
    // } else {
    //   // SET_RGB(0b110000);
    //   SET_RGB(0b111111);
  }
  SET_RGB(0b111111);
  // SET_RGB(0b010111);
  // SET_RGB(0b000000);
}

static inline void send_line(int y, const struct sharp_mip_config *cfg) {
  GSET(bsp);
  GSET(bck);
  GCLR(bck);
  GCLR(bsp);

  for (int i = 3; i <= 141; i++) {
    set_rgb(y, i);
    GTOG(bck);
  }

  // Remaining 3 clock cycles.
  for (int i = 0; i < 3; i++) {
    GTOG(bck);
  }
}

static int sharp_mip_write(const struct device *dev, const uint16_t x,
                           const uint16_t y,
                           const struct display_buffer_descriptor *desc,
                           const void *buf) {
  const struct sharp_mip_config *cfg = dev->config;

  LOG_DBG("Sharp MIP display write. x: %d, y: %d", x, y);

  GSET(intb);
  GSET(gsp);
  GSET(gck);
  GCLR(gck);

  send_line(0, cfg);

  GCLR(gsp);

  for (int i = 3; i <= 561; i++) {
    GTOG(gck);
    GSET(gen);

    send_line((i - 2) / 2, cfg);

    GCLR(gen);
  }

  // GCK edge 562 -- no data.
  GTOG(gck);
  GSET(gen);
  GCLR(gen);
  GTOG(gck);

  for (int i = 563; i <= 568; i++) {
    GTOG(gck);
    if (i == 566) {
      GCLR(intb);
      continue;
    }
  }

  // GCLR(intb);

  return 0;
}

static void sharp_mip_get_capabilities(
    const struct device *dev, struct display_capabilities *capabilities) {
  const struct sharp_mip_config *config = dev->config;

  capabilities->x_resolution = config->width;
  capabilities->y_resolution = config->height;
  // TODO: This is wasteful. We are allocating 16 bits per pixel here, and we
  // only need 6 bits per pixel. In 2025-03, Zephyr introduced
  // (https://github.com/zephyrproject-rtos/zephyr/pull/86821) the
  // PIXEL_FORMAT_L_8. It's intended for 8-bit grayscale, but I think we can use
  // it for 6-bit color here, saving us half the buffer size.
  // capabilities->supported_pixel_formats = PIXEL_FORMAT_RGB_565;
  // capabilities->current_pixel_format = PIXEL_FORMAT_RGB_565;
  capabilities->supported_pixel_formats = PIXEL_FORMAT_MONO01;
  capabilities->current_pixel_format = PIXEL_FORMAT_MONO01;
  capabilities->screen_info = 0;
  // TODO: get from config.
  capabilities->current_orientation = DISPLAY_ORIENTATION_NORMAL;
}

struct display_driver_api sharp_mip_driver_api = {
    .write = sharp_mip_write,
    .get_capabilities = sharp_mip_get_capabilities,
};

#define SHARP_MIP_DEFINE(node_id)                                  \
  static struct sharp_mip_data data_##node_id;                     \
  static const struct sharp_mip_config config_##node_id = {        \
      .height = DT_PROP(node_id, height),                          \
      .width = DT_PROP(node_id, width),                            \
      .vcom_vb = GPIO_DT_SPEC_GET(node_id, vb_gpios),              \
      .va = GPIO_DT_SPEC_GET(node_id, va_gpios),                   \
      .intb = GPIO_DT_SPEC_GET(node_id, intb_gpios),               \
      .gsp = GPIO_DT_SPEC_GET(node_id, gsp_gpios),                 \
      .gck = GPIO_DT_SPEC_GET(node_id, gck_gpios),                 \
      .gen = GPIO_DT_SPEC_GET(node_id, gen_gpios),                 \
      .bsp = GPIO_DT_SPEC_GET(node_id, bsp_gpios),                 \
      .bck = GPIO_DT_SPEC_GET(node_id, bck_gpios),                 \
      .rgb = {GPIO_DT_SPEC_GET_BY_IDX(node_id, rgb_gpios, 0),      \
              GPIO_DT_SPEC_GET_BY_IDX(node_id, rgb_gpios, 1),      \
              GPIO_DT_SPEC_GET_BY_IDX(node_id, rgb_gpios, 2),      \
              GPIO_DT_SPEC_GET_BY_IDX(node_id, rgb_gpios, 3),      \
              GPIO_DT_SPEC_GET_BY_IDX(node_id, rgb_gpios, 4),      \
              GPIO_DT_SPEC_GET_BY_IDX(node_id, rgb_gpios, 5)},     \
  };                                                               \
  DEVICE_DT_DEFINE(node_id, sharp_mip_init, NULL, &data_##node_id, \
                   &config_##node_id, POST_KERNEL,                 \
                   CONFIG_DISPLAY_INIT_PRIORITY, &sharp_mip_driver_api);

DT_FOREACH_STATUS_OKAY(sharp_ls0xxb7_bitbang, SHARP_MIP_DEFINE);