// Zephyr bit-banging display driver for Sharp Memory LCDs with the 6-bit
// parallel interface.

// This driver assumes VCOM/VB and VA signals are generated by a separate
// process.

// API docs:
// https://docs.zephyrproject.org/latest/doxygen/html/group__display__interface.html

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(sharp_mip_parallel, CONFIG_DISPLAY_LOG_LEVEL);

#include <stdint.h>
#include <zephyr/drivers/display.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/kernel.h>

#include "display_sharp_ls0xxb7_bitbang_nrf_macros.h"

// Private mutable data for the driver.
struct sharp_mip_data {};

// Private const data for the driver.
struct sharp_mip_config {
  uint16_t height;
  uint16_t width;
  struct gpio_dt_spec vcom_vb;
  struct gpio_dt_spec va;

  struct gpio_dt_spec intb;
  struct gpio_dt_spec gsp;
  struct gpio_dt_spec gck;
  struct gpio_dt_spec gen;
  struct gpio_dt_spec bsp;
  struct gpio_dt_spec bck;
  struct gpio_dt_spec rgb[6];
};

#define SET_GPIO_OUTPUT(ret, name)                       \
  do {                                                   \
    if (!device_is_ready(name.port)) {                   \
      LOG_ERR(#name " GPIO port not ready");             \
      return -ENODEV;                                    \
    }                                                    \
    ret = gpio_pin_configure_dt(&name, GPIO_OUTPUT);     \
    if (ret < 0) {                                       \
      LOG_ERR(#name " GPIO pin config failed: %d", ret); \
      return ret;                                        \
    }                                                    \
  } while (0)

static int sharp_mip_init(const struct device *dev) {
  const struct sharp_mip_config *config = dev->config;
  int ret;

  SET_GPIO_OUTPUT(ret, config->intb);
  SET_GPIO_OUTPUT(ret, config->gsp);
  SET_GPIO_OUTPUT(ret, config->gck);
  SET_GPIO_OUTPUT(ret, config->gen);
  SET_GPIO_OUTPUT(ret, config->bsp);
  SET_GPIO_OUTPUT(ret, config->bck);
  for (int i = 0; i < sizeof(config->rgb) / sizeof(config->rgb[0]); i++) {
    SET_GPIO_OUTPUT(ret, config->rgb[i]);
  }

  // TODO: Create a simple Zephyr thread to generate VCOM/VB and VA signals.
  // This must be optionally disabled by config, as users may generate these
  // signals elsewhere, possibly also in hardware.
  // SET_GPIO_OUTPUT(ret, config->vcom_vb);
  // SET_GPIO_OUTPUT(ret, config->va);

  LOG_DBG("Sharp MIP display initialized. Resolution: %dx%d", config->width,
          config->height);

  return 0;
}

static inline void set_rgb(int y, int x, const void *buf) {
#if CONFIG_SHARP_LS0XXB7_DISPLAY_MODE_COLOR
  // Our display supports 6-bit colors, but Zephyr + LVGL uses at least 16-bit
  // colors. Here we need to convert them.
  size_t offset = 2 * (280 * y + x);
  uint8_t *off_buf = (uint8_t *)buf + offset;
  uint8_t r = off_buf[1] >> 3;
  uint8_t g = (off_buf[1] & 0x7) << 3 | (off_buf[0] >> 5);
  uint8_t b_ = off_buf[0] & 0x1f;
  SET_RGB((CVT_5_TO_2_BITS(r) << 4) | (CVT_6_TO_2_BITS(g) << 2) |
          (CVT_5_TO_2_BITS(b_)));

#elif CONFIG_SHARP_LS0XXB7_DISPLAY_MODE_MONOCHROME
  size_t byte_pos = (280 / 8 * y + (x / 8));
  size_t bit_pos = x % 8;
  if (((uint8_t *)buf)[byte_pos] & (1 << bit_pos)) {
    SET_RGB(0b000000);
  } else {
    SET_RGB(0b111111);
  }
#endif  // CONFIG_SHARP_LS0XXB7_DISPLAY_MODE
}

static inline void send_line(int y, const struct sharp_mip_config *cfg,
                             const void *buf) {
  GSET(bsp);
  GSET(bck);
  GCLR(bck);
  GCLR(bsp);

  for (int i = 3; i <= 141; i++) {
    set_rgb(y, i, buf);
    GTOG(bck);
  }

  // Remaining 3 clock cycles.
  for (int i = 0; i < 3; i++) {
    GTOG(bck);
  }
}

static int sharp_mip_write(const struct device *dev, const uint16_t x,
                           const uint16_t y,
                           const struct display_buffer_descriptor *desc,
                           const void *buf) {
  const struct sharp_mip_config *cfg = dev->config;

  // Offset for GCK. For full-screen updates, this is 2. For partial updates,
  // it's 2 plus the number of half-lines to skip.
  const int gck_offset = 2 + y * 2;

  // The last GCK index of the last sent half-line.
  const int gck_last_half_line = gck_offset + 2 * desc->height - 1;

  LOG_DBG(
      "Sharp MIP display write. x: %d, y: %d; buf size: %d (buf height: %d, "
      "buf width: %d). Offset: %d, last: %d",
      x, y, desc->buf_size, desc->height, desc->width, gck_offset,
      gck_last_half_line);

  GCLR(gck);

  GSET(intb);
  GSET(gsp);

  // 1-indexed to match the datasheet and improve debugging.
  for (int i = 1; i <= 568; i++) {
    GTOG(gck);

    if (i == 2) {
      GCLR(gsp);
    }

    if (i == gck_offset) {
      send_line(0, cfg, buf);
    } else if (i >= gck_offset + 1 && i <= gck_last_half_line) {
      GSET(gen);
      const uint16_t display_line = (i - gck_offset) / 2;

#if CONFIG_SHARP_LS0XXB7_DISPLAY_MODE_COLOR
      // Color buffer, 16 bits per pixel.
      // Each line has 280 pixels, which is 280 * 2 = 560 bytes.
      uint8_t *line_buf = (uint8_t *)buf + display_line * 560;
#elif CONFIG_SHARP_LS0XXB7_DISPLAY_MODE_MONOCHROME
      // Monochrome buffer, 1 bit per pixel.
      // Each line has 280 pixels, which is 280 / 8 = 35 bytes.
      uint8_t *line_buf = (uint8_t *)buf + display_line * 35;
#endif  // CONFIG_SHARP_LS0XXB7_DISPLAY_MODE

      send_line(0, cfg, line_buf);
      GCLR(gen);
    } else if (i == gck_last_half_line + 1) {
      GSET(gen);
      GCLR(gen);
    } else if (i == 566) {
      GCLR(intb);
    }
  }

  return 0;
}

static void sharp_mip_get_capabilities(
    const struct device *dev, struct display_capabilities *capabilities) {
  const struct sharp_mip_config *config = dev->config;

  capabilities->x_resolution = config->width;
  capabilities->y_resolution = config->height;

#if CONFIG_SHARP_LS0XXB7_DISPLAY_MODE_COLOR
  // TODO: This is wasteful. We are requesting 16 bits per pixel here, and we
  // only need 6 bits per pixel. In 2025-03, Zephyr introduced
  // (https://github.com/zephyrproject-rtos/zephyr/pull/86821) the
  // PIXEL_FORMAT_L_8. It's intended for 8-bit grayscale, but I think we can use
  // it for 6-bit color here, saving us half the buffer size.
  capabilities->supported_pixel_formats = PIXEL_FORMAT_RGB_565;
  capabilities->current_pixel_format = PIXEL_FORMAT_RGB_565;
#elif CONFIG_SHARP_LS0XXB7_DISPLAY_MODE_MONOCHROME
  capabilities->supported_pixel_formats = PIXEL_FORMAT_MONO01;
  capabilities->current_pixel_format = PIXEL_FORMAT_MONO01;
#endif  // CONFIG_SHARP_LS0XXB7_DISPLAY_MODE

  capabilities->screen_info = 0;

  // TODO: get from config.
  capabilities->current_orientation = DISPLAY_ORIENTATION_NORMAL;
}

struct display_driver_api sharp_mip_driver_api = {
    .write = sharp_mip_write,
    .get_capabilities = sharp_mip_get_capabilities,
};

#define SHARP_MIP_DEFINE(node_id)                                  \
  static struct sharp_mip_data data_##node_id;                     \
  static const struct sharp_mip_config config_##node_id = {        \
      .height = DT_PROP(node_id, height),                          \
      .width = DT_PROP(node_id, width),                            \
      .vcom_vb = GPIO_DT_SPEC_GET(node_id, vb_gpios),              \
      .va = GPIO_DT_SPEC_GET(node_id, va_gpios),                   \
      .intb = GPIO_DT_SPEC_GET(node_id, intb_gpios),               \
      .gsp = GPIO_DT_SPEC_GET(node_id, gsp_gpios),                 \
      .gck = GPIO_DT_SPEC_GET(node_id, gck_gpios),                 \
      .gen = GPIO_DT_SPEC_GET(node_id, gen_gpios),                 \
      .bsp = GPIO_DT_SPEC_GET(node_id, bsp_gpios),                 \
      .bck = GPIO_DT_SPEC_GET(node_id, bck_gpios),                 \
      .rgb = {GPIO_DT_SPEC_GET_BY_IDX(node_id, rgb_gpios, 0),      \
              GPIO_DT_SPEC_GET_BY_IDX(node_id, rgb_gpios, 1),      \
              GPIO_DT_SPEC_GET_BY_IDX(node_id, rgb_gpios, 2),      \
              GPIO_DT_SPEC_GET_BY_IDX(node_id, rgb_gpios, 3),      \
              GPIO_DT_SPEC_GET_BY_IDX(node_id, rgb_gpios, 4),      \
              GPIO_DT_SPEC_GET_BY_IDX(node_id, rgb_gpios, 5)},     \
  };                                                               \
  DEVICE_DT_DEFINE(node_id, sharp_mip_init, NULL, &data_##node_id, \
                   &config_##node_id, POST_KERNEL,                 \
                   CONFIG_DISPLAY_INIT_PRIORITY, &sharp_mip_driver_api);

DT_FOREACH_STATUS_OKAY(sharp_ls0xxb7_bitbang, SHARP_MIP_DEFINE);